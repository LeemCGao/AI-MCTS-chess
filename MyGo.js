!function(g){var I={};function C(A){if(I[A])return I[A].exports;var l=I[A]={i:A,l:!1,exports:{}};return g[A].call(l.exports,l,l.exports,C),l.l=!0,l.exports}C.m=g,C.c=I,C.d=function(g,I,A){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:A})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var A=Object.create(null);if(C.r(A),Object.defineProperty(A,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var l in g)C.d(A,l,function(I){return g[I]}.bind(null,l));return A},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="",C(C.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/Cell.js\n\r\nclass Cell{\r\n    constructor(x, y, color, head, next, state, idx) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.color = color || 0;\r\n        this.head = head || this;\r\n        this.next = next;\r\n        this.state = state;\r\n        this.qi = {};\r\n        this.idx = idx;\r\n\r\n        this.initQi();\r\n    }\r\n\r\n    initQi(){\r\n        let x = this.x;\r\n        let y = this.y;\r\n        if(y-1>=0){\r\n            let idx = this.state.xy2idx(x,y-1);\r\n            if(!this.state.cellMap[idx]){\r\n                this.qi[idx] = true;\r\n            }\r\n        }\r\n        if(y+1<this.state.boardWidth){\r\n            let idx = this.state.xy2idx(x,y+1);\r\n            if(!this.state.cellMap[idx]){\r\n                this.qi[idx] = true;\r\n            }\r\n        }\r\n        if(x-1>=0){\r\n            let idx = this.state.xy2idx(x-1,y);\r\n            if(!this.state.cellMap[idx]){\r\n                this.qi[idx] = true;\r\n            }\r\n        }\r\n        if(x+1<this.state.boardWidth){\r\n            let idx = this.state.xy2idx(x+1,y);\r\n            if(!this.state.cellMap[idx]){\r\n                this.qi[idx] = true;\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    clone(){\r\n        return new Cell(this.x, this.y, this.color, this.head, this.next, this.state, this.idx);\r\n    }\r\n\r\n    mergeBlock(cell2){\r\n        \r\n        for(let idx2 in cell2.qi){\r\n            if(idx2 == this.idx){\r\n                delete cell2.qi[idx2];\r\n                for(let idx in this.qi){\r\n                    cell2.qi[idx] = true;\r\n                }\r\n                this.qi = cell2.qi;\r\n\r\n                let cell = this;\r\n                while(cell.next){\r\n                    cell = cell.next;\r\n                }\r\n                cell.next = cell2;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n\r\n    }\r\n\r\n    deleteQi(cell2){\r\n        for(let idx in this.qi){\r\n            if(idx == cell2.idx){\r\n                delete this.qi[idx];\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    addQi(cell3){\r\n\r\n        let cell2 = cell3;\r\n        do{\r\n            let cell = this;\r\n            do{\r\n                if(cell.idx-this.state.boardWidth == cell2.idx || cell.idx+this.state.boardWidth == cell2.idx || cell.x>0&&cell.idx-1 == cell2.idx || cell.x<this.state.boardWidth-1&&cell.idx+1 == cell2.idx){\r\n                    this.qi[cell2.idx] = true;\r\n                    break;\r\n                }\r\n                cell = cell.next;\r\n            }while(cell);\r\n            cell2 = cell2.next;\r\n        }while(cell2);\r\n\r\n    }\r\n\r\n    getQiCount(){\r\n\r\n        let count = 0;\r\n        for(let idx in this.qi){\r\n            count ++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    getCount(){\r\n\r\n        let count = 1;\r\n        let cell = this;\r\n        while(cell.next){\r\n            count ++;\r\n            cell = cell.next;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var src_Cell = (Cell);\n// CONCATENATED MODULE: ./src/Node.js\n//mcts的节点\r\n\r\n\r\n\r\nclass Node_Node{\r\n    constructor(param){\r\n        this.father = param.father;\r\n        this.ucb = Infinity;\r\n        this.Q = 0;\r\n        this.N = 0;\r\n        this.children = [];\r\n        this.maxUCBChild = null;\r\n        this.state = param.state;\r\n    }\r\n\r\n    runOnce(){\r\n        let selectedNode = this;\r\n\r\n        while(selectedNode.children.length>0){\r\n            selectedNode = selectedNode.setMaxUCBChild();\r\n        }\r\n\r\n        if(selectedNode.N>0){\r\n            if(selectedNode.end){\r\n                this.backpropagation(selectedNode.winColor, selectedNode);\r\n                return;\r\n            }\r\n            selectedNode.createChildren();\r\n            if(selectedNode.end){\r\n                this.backpropagation(selectedNode.winColor, selectedNode);\r\n                return;\r\n            }\r\n            selectedNode = selectedNode.children[0];\r\n        }\r\n\r\n        let winColor = selectedNode.simulate();\r\n        let node = selectedNode;\r\n\r\n        this.backpropagation(winColor, node);\r\n        \r\n    }\r\n\r\n    backpropagation(winColor, node){\r\n        do{\r\n            node.updateQN(winColor);\r\n            node = node.father;\r\n        }while(node);\r\n    }\r\n\r\n    updateQN(winColor){\r\n        this.N++;\r\n        if(winColor===this.state.lastMove.color){\r\n            this.Q++;\r\n        }\r\n    }\r\n\r\n    setMaxUCBChild(){\r\n        let max = -Infinity;\r\n        for(let idx in this.children){\r\n            let ucb = this.children[idx].updateUCB();\r\n            if(ucb>max){\r\n                max = ucb;\r\n                this.maxUCBChild = this.children[idx];\r\n            }\r\n        }\r\n        return this.maxUCBChild;\r\n    }\r\n\r\n    getMaxNChild(){\r\n        let max = -Infinity;\r\n        let best;\r\n        for(let idx in this.children){\r\n            let N = this.children[idx].N;\r\n            if(N>max){\r\n                max = N;\r\n                best = this.children[idx];\r\n            }else if(N===max){\r\n                if(this.children[idx].Q>best.Q){\r\n                    max = N;\r\n                    best = this.children[idx];\r\n                }\r\n            }\r\n        }\r\n        return best;\r\n    }\r\n\r\n    createChildren(){\r\n        let color = -this.state.lastMove.color;\r\n        for(let x=0; x<this.state.boardWidth; x++){\r\n            for(let y=0; y<this.state.boardWidth; y++){\r\n                let idx = this.state.xy2idx(x,y);\r\n                if(!this.state.cellMap[idx]){\r\n                    let state = this.state.checkPiece(x,y,color);\r\n                    if(state){\r\n                        let node = new Node_Node({\r\n                            state: state,\r\n                            father: this,\r\n                        });\r\n                        this.children.push(node);\r\n                    }\r\n                    \r\n                }\r\n            }\r\n        }\r\n\r\n        if(this.children.length===0){\r\n            if(this.state.lastMove.x===-1){\r\n                this.end = true;\r\n            }else{\r\n                let idx = this.state.xy2idx(-1,-1);\r\n                let state = this.state.clone();\r\n                let cell = new src_Cell(-1, -1, color, null, null, state, idx);\r\n                state.lastMove = cell;\r\n                let node = new Node_Node({\r\n                    state: state,\r\n                    father: this,\r\n                });\r\n                this.children.push(node);\r\n            }\r\n        }\r\n    }\r\n\r\n    simulate(){\r\n        let lastX;\r\n        let end = false;\r\n        let state = this.state;\r\n        do{\r\n\r\n            let color = -state.lastMove.color;\r\n            let normalMove = [];\r\n            // let fillEyeMove = [];\r\n            let oneQiMove = [];\r\n            for(let x=0; x<state.boardWidth; x++){\r\n                for(let y=0; y<state.boardWidth; y++){\r\n                    let idx = state.xy2idx(x,y);\r\n                    if(!state.cellMap[idx]){\r\n                        let checkRes = state.checkPiece(x,y,color);\r\n                        if(checkRes){\r\n                            if(checkRes.result === 1){\r\n                                normalMove.push(checkRes);\r\n                            }else if(checkRes.result === 2){\r\n                                // fillEyeMove.push(checkRes);\r\n                            }else if(checkRes.result === 3){\r\n                                oneQiMove.push(checkRes);\r\n                            }\r\n\r\n                        }\r\n                        \r\n                    }\r\n                }\r\n            }\r\n\r\n            let allMove = normalMove.concat(oneQiMove);\r\n            if(normalMove.length===0){\r\n\r\n                let idx = state.xy2idx(-1,-1);\r\n                let state1 = state.clone();\r\n                let cell = new src_Cell(-1, -1, color, null, null, state1, idx);\r\n                state1.lastMove = cell;\r\n                allMove.push(state1);\r\n            }\r\n\r\n            let selectIdx = this.getRandomInt(allMove.length);\r\n\r\n            let selected = allMove[selectIdx];\r\n\r\n            if(selected.lastMove.x === -1){\r\n                if(lastX === -1){\r\n                    end = true;\r\n                }\r\n            }\r\n            lastX = selected.lastMove.x;\r\n\r\n            state = selected;\r\n        }while(!end);\r\n\r\n        let winColor = this.getWinColor(state);\r\n\r\n        this.winColor = winColor;\r\n        return winColor;\r\n\r\n    }\r\n\r\n    getWinColor(state){\r\n        let black = 0;\r\n        let white = 0;\r\n\r\n        let blackQi = {};\r\n        let whiteQi = {};\r\n\r\n        let blocks = state.blocks;\r\n        for(let i=0; i<blocks.length; i++){\r\n            let ziCount = blocks[i].getCount();\r\n\r\n            if(blocks[i].color === 1){\r\n                black += ziCount;\r\n                for(let idx in blocks[i].qi){\r\n                    blackQi[idx] = true;\r\n                }\r\n            }else{\r\n                white += ziCount;\r\n                for(let idx in blocks[i].qi){\r\n                    whiteQi[idx] = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        let blackQiCount = 0;\r\n        let whiteQiCount = 0;\r\n        for(let k in blackQi){\r\n            blackQiCount ++;\r\n        }\r\n        for(let k in whiteQi){\r\n            whiteQiCount ++;\r\n        }\r\n        black += blackQiCount;\r\n        white += whiteQiCount;\r\n\r\n        if(black>white){\r\n            return 1;\r\n        }else{\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    getRandomInt(max) {\r\n        return Math.floor(Math.random() * max);\r\n      }\r\n\r\n    updateUCB(){\r\n        if(this.N===0){\r\n            return Infinity;\r\n        }\r\n        this.ucb = this.Q/this.N + Math.sqrt(2*Math.log(this.father.N)/this.N);\r\n        return this.ucb;\r\n    }\r\n\r\n    getChild(x,y){\r\n        for(let idx in this.children){\r\n            let lastMove = this.children[idx].state.lastMove;\r\n            if(lastMove.x===x&&lastMove.y===y){\r\n                return this.children[idx];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/* harmony default export */ var src_Node = (Node_Node);\n// CONCATENATED MODULE: ./src/State.js\n\r\n\r\nclass State_State{\r\n    constructor(param) {\r\n        this.cellMap = {};\r\n        this.blocks = [];\r\n        this.boardWidth = param.boardWidth;\r\n        this.lastMove = param.lastMove;\r\n    }\r\n\r\n    xy2idx(x,y){\r\n        return y*this.boardWidth+x;\r\n    }\r\n\r\n    idx2xy(idx){\r\n        let x = idx%this.boardWidth;\r\n        let y = (idx-x)/this.boardWidth;\r\n        return [x,y];\r\n    }\r\n\r\n    clone(){\r\n        let state = new State_State({\r\n            boardWidth: this.boardWidth,\r\n            lastMove: this.lastMove\r\n        });\r\n        state.jie = this.jie;\r\n\r\n        let cellMap = {};\r\n        for(let idx in this.cellMap){\r\n            cellMap[idx] = this.cellMap[idx];\r\n        }\r\n        state.cellMap = cellMap;\r\n\r\n        let blocks = [];\r\n        for(let i=0; i<this.blocks.length; i++){\r\n            let head = this.blocks[i];\r\n            let head2 = new src_Cell(head.x, head.y, head.color, null, null, state, head.idx);\r\n\r\n            let qi = {};\r\n            for(let idxQi in head.qi){\r\n                qi[idxQi] = head.qi[idxQi];\r\n            }\r\n            head2.qi = qi;\r\n\r\n            let head3 = head2;\r\n\r\n            while(head.next){\r\n                head = head.next;\r\n                let child2 = new src_Cell(head.x, head.y, head.color, null, null, state, head.idx);\r\n                head3.next = child2;\r\n                head3 = child2;\r\n            }\r\n\r\n            blocks.push(head2);\r\n        }\r\n        state.blocks = blocks;\r\n\r\n        return state;\r\n\r\n    }\r\n\r\n    checkPiece(x,y,color){\r\n        let state = this.clone();\r\n        let result = state.placePiece(x,y,color);\r\n        if(result){\r\n            state.result = result;\r\n            return state;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    placePiece(x,y,color){\r\n\r\n        let idx = this.xy2idx(x,y);\r\n        let cell = new src_Cell(x,y,color,null,null,this,idx);\r\n\r\n        this.cellMap[idx] = color;\r\n\r\n        //合并\r\n        let hasMerge = false;\r\n        for(let i = 0; i < this.blocks.length; i++) {\r\n\r\n            if(this.blocks[i].color !== color) {\r\n                continue;\r\n            }\r\n\r\n           let merge = cell.mergeBlock(this.blocks[i]);\r\n           if(merge){\r\n                hasMerge = true;\r\n                this.blocks.splice(i,1);\r\n                i--;\r\n           }\r\n        }\r\n\r\n        this.blocks.push(cell);\r\n\r\n        let jie;\r\n        //判断提\r\n        let hasKill = false;\r\n        for(let i = 0; i < this.blocks.length; i++) {\r\n            if(this.blocks[i].color === color) {\r\n                continue;\r\n            }\r\n\r\n            let del = this.blocks[i].deleteQi(cell);\r\n            if(del){\r\n                let qiCount = this.blocks[i].getQiCount();\r\n                if(qiCount === 0) {\r\n\r\n                    let ziCount = this.blocks[i].getCount();\r\n\r\n                    //jie\r\n                    if(this.jie){\r\n                        if(cell.idx == this.jie.idx){\r\n                            \r\n                            if(ziCount===1){\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    hasKill = true;\r\n\r\n                    if(ziCount===1){\r\n                        jie = this.blocks[i];\r\n                    }\r\n\r\n                    //加气\r\n                    for(let j = 0; j < this.blocks.length; j++) {\r\n\r\n                        if(this.blocks[j].color !== color) {\r\n                            continue;\r\n                        }\r\n            \r\n                        this.blocks[j].addQi(this.blocks[i]);\r\n                    }\r\n\r\n                    let cellKilled = this.blocks[i];\r\n                    do{\r\n                        delete this.cellMap[cellKilled.idx];\r\n                        cellKilled = cellKilled.next;\r\n                    }while(cellKilled);\r\n                   \r\n                    this.blocks.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n            \r\n        }\r\n\r\n        let cellQi = cell.getQiCount();\r\n        let hasQi = cellQi>0;\r\n\r\n        if(!hasKill && !hasQi){\r\n            return false;\r\n        }else{\r\n            this.lastMove = cell;\r\n            this.jie = jie;\r\n\r\n            let result = 1;\r\n            if(!hasKill){\r\n                let fillEye = this.checkEye(cell);\r\n                if(fillEye){\r\n                    result = 2;\r\n                }else{\r\n                    if(cellQi === 1){\r\n                        result = 3;\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n    }\r\n\r\n    checkEye(cell){\r\n        let x = cell.x;\r\n        let y = cell.y;\r\n        let color = cell.color;\r\n        let isEye = true;\r\n\r\n        if(y-1>=0){\r\n            let idx = this.xy2idx(x,y-1);\r\n            if(this.cellMap[idx]!=color){\r\n                return false;\r\n            }\r\n        }\r\n        if(y+1<this.boardWidth){\r\n            let idx = this.xy2idx(x,y+1);\r\n            if(this.cellMap[idx]!=color){\r\n                return false;\r\n            }\r\n        }\r\n        if(x-1>=0){\r\n            let idx = this.xy2idx(x-1,y);\r\n            if(this.cellMap[idx]!=color){\r\n                return false;\r\n            }\r\n        }\r\n        if(x+1<this.boardWidth){\r\n            let idx = this.xy2idx(x+1,y);\r\n            if(this.cellMap[idx]!=color){\r\n                return false;\r\n            }\r\n        }\r\n\r\n        let corner = 0;\r\n        let enemy = 0;\r\n        if(x-1>=0){\r\n            if(y-1>=0){\r\n                corner++;\r\n                let idx = this.xy2idx(x-1,y-1);\r\n                if(this.cellMap[idx]==-color){\r\n                    enemy++;\r\n                }\r\n            }\r\n            if(y+1<this.boardWidth){\r\n                corner++;\r\n                let idx = this.xy2idx(x-1,y+1);\r\n                if(this.cellMap[idx]==-color){\r\n                    enemy++;\r\n                }\r\n            }\r\n        }\r\n        if(x+1<this.boardWidth){\r\n            if(y-1>=0){\r\n                corner++;\r\n                let idx = this.xy2idx(x+1,y-1);\r\n                if(this.cellMap[idx]==-color){\r\n                    enemy++;\r\n                }\r\n            }\r\n            if(y+1<this.boardWidth){\r\n                corner++;\r\n                let idx = this.xy2idx(x+1,y+1);\r\n                if(this.cellMap[idx]==-color){\r\n                    enemy++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(enemy/corner>=0.5){\r\n            return false;\r\n        }else{\r\n            return true;\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var src_State = (State_State);\n// CONCATENATED MODULE: ./src/Game.js\n\r\n\r\n\r\n\r\nclass Game_Game{\r\n    constructor(boardWidth) {\r\n        this.curColor = 1;\r\n        this.boardWidth = boardWidth || 5;\r\n        this.curState = new src_State({\r\n            boardWidth: this.boardWidth,\r\n            \r\n        });\r\n        this.curState.lastMove = new src_Cell(-1,-1,-1,null,null,this.curState,this.curState.xy2idx(-1,-1));\r\n        this.node = new src_Node({\r\n            state: this.curState\r\n        });\r\n        \r\n    }\r\n\r\n    //人机对弈\r\n    placePiece(x,y,color){\r\n\r\n        if(color===1){\r\n            let state = this.checkPiece(x,y,color);\r\n            if(state){\r\n                this.curState = state;\r\n                this.curColor = -this.curColor;\r\n\r\n                //ai\r\n                let node = this.node.getChild(x,y);\r\n                if(!node){\r\n                    node = new src_Node({\r\n                        state: this.curState\r\n                    });\r\n                }\r\n                for(let i=0; i<1000; i++){\r\n                    node.runOnce();\r\n                }\r\n                let bestChild = node.getMaxNChild();\r\n                if(bestChild){\r\n                    // let cell = bestChild.state.lastMove;\r\n                    this.curState = bestChild.state;\r\n                    this.curColor = -this.curColor;\r\n                    this.node = bestChild;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    //人人对弈\r\n    placePiecePVP(x,y,color){\r\n        let state = this.checkPiece(x,y,color);\r\n        if(state){\r\n            this.curState = state;\r\n            this.curColor = -this.curColor;\r\n        }\r\n    }\r\n\r\n    checkPiece(x,y,color){\r\n        let state = this.curState.clone();\r\n        let valid = state.placePiece(x,y,color);\r\n        if(valid){\r\n            return state;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/* harmony default export */ var src_Game = (Game_Game);\n// CONCATENATED MODULE: ./src/main.js\n\r\n\r\nlet MyGo = {};\r\nMyGo.Game = src_Game;\r\n\r\nwindow.MyGo = MyGo;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9DZWxsLmpzP2NhZmIiLCJ3ZWJwYWNrOi8vLy4vc3JjL05vZGUuanM/MGI4ZCIsIndlYnBhY2s6Ly8vLi9zcmMvU3RhdGUuanM/ZGE4OCIsIndlYnBhY2s6Ly8vLi9zcmMvR2FtZS5qcz84NDA0Iiwid2VicGFjazovLy8uL3NyYy9tYWluLmpzPzU2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbmNsYXNzIENlbGx7XHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBjb2xvciwgaGVhZCwgbmV4dCwgc3RhdGUsIGlkeCkge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3IgfHwgMDtcclxuICAgICAgICB0aGlzLmhlYWQgPSBoZWFkIHx8IHRoaXM7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgdGhpcy5xaSA9IHt9O1xyXG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xyXG5cclxuICAgICAgICB0aGlzLmluaXRRaSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXRRaSgpe1xyXG4gICAgICAgIGxldCB4ID0gdGhpcy54O1xyXG4gICAgICAgIGxldCB5ID0gdGhpcy55O1xyXG4gICAgICAgIGlmKHktMT49MCl7XHJcbiAgICAgICAgICAgIGxldCBpZHggPSB0aGlzLnN0YXRlLnh5MmlkeCh4LHktMSk7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnN0YXRlLmNlbGxNYXBbaWR4XSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnFpW2lkeF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHkrMTx0aGlzLnN0YXRlLmJvYXJkV2lkdGgpe1xyXG4gICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy5zdGF0ZS54eTJpZHgoeCx5KzEpO1xyXG4gICAgICAgICAgICBpZighdGhpcy5zdGF0ZS5jZWxsTWFwW2lkeF0pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xaVtpZHhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZih4LTE+PTApe1xyXG4gICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy5zdGF0ZS54eTJpZHgoeC0xLHkpO1xyXG4gICAgICAgICAgICBpZighdGhpcy5zdGF0ZS5jZWxsTWFwW2lkeF0pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xaVtpZHhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZih4KzE8dGhpcy5zdGF0ZS5ib2FyZFdpZHRoKXtcclxuICAgICAgICAgICAgbGV0IGlkeCA9IHRoaXMuc3RhdGUueHkyaWR4KHgrMSx5KTtcclxuICAgICAgICAgICAgaWYoIXRoaXMuc3RhdGUuY2VsbE1hcFtpZHhdKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucWlbaWR4XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICByZXR1cm4gbmV3IENlbGwodGhpcy54LCB0aGlzLnksIHRoaXMuY29sb3IsIHRoaXMuaGVhZCwgdGhpcy5uZXh0LCB0aGlzLnN0YXRlLCB0aGlzLmlkeCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWVyZ2VCbG9jayhjZWxsMil7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKGxldCBpZHgyIGluIGNlbGwyLnFpKXtcclxuICAgICAgICAgICAgaWYoaWR4MiA9PSB0aGlzLmlkeCl7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgY2VsbDIucWlbaWR4Ml07XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGlkeCBpbiB0aGlzLnFpKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsMi5xaVtpZHhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucWkgPSBjZWxsMi5xaTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB3aGlsZShjZWxsLm5leHQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGwgPSBjZWxsLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjZWxsLm5leHQgPSBjZWxsMjtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBkZWxldGVRaShjZWxsMil7XHJcbiAgICAgICAgZm9yKGxldCBpZHggaW4gdGhpcy5xaSl7XHJcbiAgICAgICAgICAgIGlmKGlkeCA9PSBjZWxsMi5pZHgpe1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucWlbaWR4XTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRRaShjZWxsMyl7XHJcblxyXG4gICAgICAgIGxldCBjZWxsMiA9IGNlbGwzO1xyXG4gICAgICAgIGRve1xyXG4gICAgICAgICAgICBsZXQgY2VsbCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGRve1xyXG4gICAgICAgICAgICAgICAgaWYoY2VsbC5pZHgtdGhpcy5zdGF0ZS5ib2FyZFdpZHRoID09IGNlbGwyLmlkeCB8fCBjZWxsLmlkeCt0aGlzLnN0YXRlLmJvYXJkV2lkdGggPT0gY2VsbDIuaWR4IHx8IGNlbGwueD4wJiZjZWxsLmlkeC0xID09IGNlbGwyLmlkeCB8fCBjZWxsLng8dGhpcy5zdGF0ZS5ib2FyZFdpZHRoLTEmJmNlbGwuaWR4KzEgPT0gY2VsbDIuaWR4KXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnFpW2NlbGwyLmlkeF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2VsbCA9IGNlbGwubmV4dDtcclxuICAgICAgICAgICAgfXdoaWxlKGNlbGwpO1xyXG4gICAgICAgICAgICBjZWxsMiA9IGNlbGwyLm5leHQ7XHJcbiAgICAgICAgfXdoaWxlKGNlbGwyKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UWlDb3VudCgpe1xyXG5cclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgIGZvcihsZXQgaWR4IGluIHRoaXMucWkpe1xyXG4gICAgICAgICAgICBjb3VudCArKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxuXHJcbiAgICBnZXRDb3VudCgpe1xyXG5cclxuICAgICAgICBsZXQgY291bnQgPSAxO1xyXG4gICAgICAgIGxldCBjZWxsID0gdGhpcztcclxuICAgICAgICB3aGlsZShjZWxsLm5leHQpe1xyXG4gICAgICAgICAgICBjb3VudCArKztcclxuICAgICAgICAgICAgY2VsbCA9IGNlbGwubmV4dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENlbGw7IiwiLy9tY3Rz55qE6IqC54K5XHJcblxyXG5pbXBvcnQgQ2VsbCBmcm9tIFwiLi9DZWxsXCI7XHJcblxyXG5jbGFzcyBOb2Rle1xyXG4gICAgY29uc3RydWN0b3IocGFyYW0pe1xyXG4gICAgICAgIHRoaXMuZmF0aGVyID0gcGFyYW0uZmF0aGVyO1xyXG4gICAgICAgIHRoaXMudWNiID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5RID0gMDtcclxuICAgICAgICB0aGlzLk4gPSAwO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB0aGlzLm1heFVDQkNoaWxkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0YXRlID0gcGFyYW0uc3RhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgcnVuT25jZSgpe1xyXG4gICAgICAgIGxldCBzZWxlY3RlZE5vZGUgPSB0aGlzO1xyXG5cclxuICAgICAgICB3aGlsZShzZWxlY3RlZE5vZGUuY2hpbGRyZW4ubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGUuc2V0TWF4VUNCQ2hpbGQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHNlbGVjdGVkTm9kZS5OPjApe1xyXG4gICAgICAgICAgICBpZihzZWxlY3RlZE5vZGUuZW5kKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFja3Byb3BhZ2F0aW9uKHNlbGVjdGVkTm9kZS53aW5Db2xvciwgc2VsZWN0ZWROb2RlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWxlY3RlZE5vZGUuY3JlYXRlQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgaWYoc2VsZWN0ZWROb2RlLmVuZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2twcm9wYWdhdGlvbihzZWxlY3RlZE5vZGUud2luQ29sb3IsIHNlbGVjdGVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2RlLmNoaWxkcmVuWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHdpbkNvbG9yID0gc2VsZWN0ZWROb2RlLnNpbXVsYXRlKCk7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBzZWxlY3RlZE5vZGU7XHJcblxyXG4gICAgICAgIHRoaXMuYmFja3Byb3BhZ2F0aW9uKHdpbkNvbG9yLCBub2RlKTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBiYWNrcHJvcGFnYXRpb24od2luQ29sb3IsIG5vZGUpe1xyXG4gICAgICAgIGRve1xyXG4gICAgICAgICAgICBub2RlLnVwZGF0ZVFOKHdpbkNvbG9yKTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuZmF0aGVyO1xyXG4gICAgICAgIH13aGlsZShub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVRTih3aW5Db2xvcil7XHJcbiAgICAgICAgdGhpcy5OKys7XHJcbiAgICAgICAgaWYod2luQ29sb3I9PT10aGlzLnN0YXRlLmxhc3RNb3ZlLmNvbG9yKXtcclxuICAgICAgICAgICAgdGhpcy5RKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldE1heFVDQkNoaWxkKCl7XHJcbiAgICAgICAgbGV0IG1heCA9IC1JbmZpbml0eTtcclxuICAgICAgICBmb3IobGV0IGlkeCBpbiB0aGlzLmNoaWxkcmVuKXtcclxuICAgICAgICAgICAgbGV0IHVjYiA9IHRoaXMuY2hpbGRyZW5baWR4XS51cGRhdGVVQ0IoKTtcclxuICAgICAgICAgICAgaWYodWNiPm1heCl7XHJcbiAgICAgICAgICAgICAgICBtYXggPSB1Y2I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heFVDQkNoaWxkID0gdGhpcy5jaGlsZHJlbltpZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm1heFVDQkNoaWxkO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE1heE5DaGlsZCgpe1xyXG4gICAgICAgIGxldCBtYXggPSAtSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IGJlc3Q7XHJcbiAgICAgICAgZm9yKGxldCBpZHggaW4gdGhpcy5jaGlsZHJlbil7XHJcbiAgICAgICAgICAgIGxldCBOID0gdGhpcy5jaGlsZHJlbltpZHhdLk47XHJcbiAgICAgICAgICAgIGlmKE4+bWF4KXtcclxuICAgICAgICAgICAgICAgIG1heCA9IE47XHJcbiAgICAgICAgICAgICAgICBiZXN0ID0gdGhpcy5jaGlsZHJlbltpZHhdO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihOPT09bWF4KXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY2hpbGRyZW5baWR4XS5RPmJlc3QuUSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTjtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0ID0gdGhpcy5jaGlsZHJlbltpZHhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiZXN0O1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNoaWxkcmVuKCl7XHJcbiAgICAgICAgbGV0IGNvbG9yID0gLXRoaXMuc3RhdGUubGFzdE1vdmUuY29sb3I7XHJcbiAgICAgICAgZm9yKGxldCB4PTA7IHg8dGhpcy5zdGF0ZS5ib2FyZFdpZHRoOyB4Kyspe1xyXG4gICAgICAgICAgICBmb3IobGV0IHk9MDsgeTx0aGlzLnN0YXRlLmJvYXJkV2lkdGg7IHkrKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy5zdGF0ZS54eTJpZHgoeCx5KTtcclxuICAgICAgICAgICAgICAgIGlmKCF0aGlzLnN0YXRlLmNlbGxNYXBbaWR4XSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZS5jaGVja1BpZWNlKHgseSxjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3RhdGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBOb2RlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhdGhlcjogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoPT09MCl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3RhdGUubGFzdE1vdmUueD09PS0xKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy5zdGF0ZS54eTJpZHgoLTEsLTEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGwgPSBuZXcgQ2VsbCgtMSwgLTEsIGNvbG9yLCBudWxsLCBudWxsLCBzdGF0ZSwgaWR4KTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmxhc3RNb3ZlID0gY2VsbDtcclxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gbmV3IE5vZGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBmYXRoZXI6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaW11bGF0ZSgpe1xyXG4gICAgICAgIGxldCBsYXN0WDtcclxuICAgICAgICBsZXQgZW5kID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICBkb3tcclxuXHJcbiAgICAgICAgICAgIGxldCBjb2xvciA9IC1zdGF0ZS5sYXN0TW92ZS5jb2xvcjtcclxuICAgICAgICAgICAgbGV0IG5vcm1hbE1vdmUgPSBbXTtcclxuICAgICAgICAgICAgLy8gbGV0IGZpbGxFeWVNb3ZlID0gW107XHJcbiAgICAgICAgICAgIGxldCBvbmVRaU1vdmUgPSBbXTtcclxuICAgICAgICAgICAgZm9yKGxldCB4PTA7IHg8c3RhdGUuYm9hcmRXaWR0aDsgeCsrKXtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgeT0wOyB5PHN0YXRlLmJvYXJkV2lkdGg7IHkrKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkeCA9IHN0YXRlLnh5MmlkeCh4LHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzdGF0ZS5jZWxsTWFwW2lkeF0pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hlY2tSZXMgPSBzdGF0ZS5jaGVja1BpZWNlKHgseSxjb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoZWNrUmVzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoZWNrUmVzLnJlc3VsdCA9PT0gMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsTW92ZS5wdXNoKGNoZWNrUmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKGNoZWNrUmVzLnJlc3VsdCA9PT0gMil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlsbEV5ZU1vdmUucHVzaChjaGVja1Jlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZihjaGVja1Jlcy5yZXN1bHQgPT09IDMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZVFpTW92ZS5wdXNoKGNoZWNrUmVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgYWxsTW92ZSA9IG5vcm1hbE1vdmUuY29uY2F0KG9uZVFpTW92ZSk7XHJcbiAgICAgICAgICAgIGlmKG5vcm1hbE1vdmUubGVuZ3RoPT09MCl7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IHN0YXRlLnh5MmlkeCgtMSwtMSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhdGUxID0gc3RhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIGxldCBjZWxsID0gbmV3IENlbGwoLTEsIC0xLCBjb2xvciwgbnVsbCwgbnVsbCwgc3RhdGUxLCBpZHgpO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUxLmxhc3RNb3ZlID0gY2VsbDtcclxuICAgICAgICAgICAgICAgIGFsbE1vdmUucHVzaChzdGF0ZTEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgc2VsZWN0SWR4ID0gdGhpcy5nZXRSYW5kb21JbnQoYWxsTW92ZS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gYWxsTW92ZVtzZWxlY3RJZHhdO1xyXG5cclxuICAgICAgICAgICAgaWYoc2VsZWN0ZWQubGFzdE1vdmUueCA9PT0gLTEpe1xyXG4gICAgICAgICAgICAgICAgaWYobGFzdFggPT09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RYID0gc2VsZWN0ZWQubGFzdE1vdmUueDtcclxuXHJcbiAgICAgICAgICAgIHN0YXRlID0gc2VsZWN0ZWQ7XHJcbiAgICAgICAgfXdoaWxlKCFlbmQpO1xyXG5cclxuICAgICAgICBsZXQgd2luQ29sb3IgPSB0aGlzLmdldFdpbkNvbG9yKHN0YXRlKTtcclxuXHJcbiAgICAgICAgdGhpcy53aW5Db2xvciA9IHdpbkNvbG9yO1xyXG4gICAgICAgIHJldHVybiB3aW5Db2xvcjtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0V2luQ29sb3Ioc3RhdGUpe1xyXG4gICAgICAgIGxldCBibGFjayA9IDA7XHJcbiAgICAgICAgbGV0IHdoaXRlID0gMDtcclxuXHJcbiAgICAgICAgbGV0IGJsYWNrUWkgPSB7fTtcclxuICAgICAgICBsZXQgd2hpdGVRaSA9IHt9O1xyXG5cclxuICAgICAgICBsZXQgYmxvY2tzID0gc3RhdGUuYmxvY2tzO1xyXG4gICAgICAgIGZvcihsZXQgaT0wOyBpPGJsb2Nrcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCB6aUNvdW50ID0gYmxvY2tzW2ldLmdldENvdW50KCk7XHJcblxyXG4gICAgICAgICAgICBpZihibG9ja3NbaV0uY29sb3IgPT09IDEpe1xyXG4gICAgICAgICAgICAgICAgYmxhY2sgKz0gemlDb3VudDtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaWR4IGluIGJsb2Nrc1tpXS5xaSl7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxhY2tRaVtpZHhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB3aGl0ZSArPSB6aUNvdW50O1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpZHggaW4gYmxvY2tzW2ldLnFpKXtcclxuICAgICAgICAgICAgICAgICAgICB3aGl0ZVFpW2lkeF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgYmxhY2tRaUNvdW50ID0gMDtcclxuICAgICAgICBsZXQgd2hpdGVRaUNvdW50ID0gMDtcclxuICAgICAgICBmb3IobGV0IGsgaW4gYmxhY2tRaSl7XHJcbiAgICAgICAgICAgIGJsYWNrUWlDb3VudCArKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGxldCBrIGluIHdoaXRlUWkpe1xyXG4gICAgICAgICAgICB3aGl0ZVFpQ291bnQgKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJsYWNrICs9IGJsYWNrUWlDb3VudDtcclxuICAgICAgICB3aGl0ZSArPSB3aGl0ZVFpQ291bnQ7XHJcblxyXG4gICAgICAgIGlmKGJsYWNrPndoaXRlKXtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0UmFuZG9tSW50KG1heCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgdXBkYXRlVUNCKCl7XHJcbiAgICAgICAgaWYodGhpcy5OPT09MCl7XHJcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51Y2IgPSB0aGlzLlEvdGhpcy5OICsgTWF0aC5zcXJ0KDIqTWF0aC5sb2codGhpcy5mYXRoZXIuTikvdGhpcy5OKTtcclxuICAgICAgICByZXR1cm4gdGhpcy51Y2I7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q2hpbGQoeCx5KXtcclxuICAgICAgICBmb3IobGV0IGlkeCBpbiB0aGlzLmNoaWxkcmVuKXtcclxuICAgICAgICAgICAgbGV0IGxhc3RNb3ZlID0gdGhpcy5jaGlsZHJlbltpZHhdLnN0YXRlLmxhc3RNb3ZlO1xyXG4gICAgICAgICAgICBpZihsYXN0TW92ZS54PT09eCYmbGFzdE1vdmUueT09PXkpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baWR4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTm9kZTsiLCJpbXBvcnQgQ2VsbCBmcm9tIFwiLi9DZWxsXCI7XHJcblxyXG5jbGFzcyBTdGF0ZXtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XHJcbiAgICAgICAgdGhpcy5jZWxsTWFwID0ge307XHJcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBbXTtcclxuICAgICAgICB0aGlzLmJvYXJkV2lkdGggPSBwYXJhbS5ib2FyZFdpZHRoO1xyXG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSBwYXJhbS5sYXN0TW92ZTtcclxuICAgIH1cclxuXHJcbiAgICB4eTJpZHgoeCx5KXtcclxuICAgICAgICByZXR1cm4geSp0aGlzLmJvYXJkV2lkdGgreDtcclxuICAgIH1cclxuXHJcbiAgICBpZHgyeHkoaWR4KXtcclxuICAgICAgICBsZXQgeCA9IGlkeCV0aGlzLmJvYXJkV2lkdGg7XHJcbiAgICAgICAgbGV0IHkgPSAoaWR4LXgpL3RoaXMuYm9hcmRXaWR0aDtcclxuICAgICAgICByZXR1cm4gW3gseV07XHJcbiAgICB9XHJcblxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICBsZXQgc3RhdGUgPSBuZXcgU3RhdGUoe1xyXG4gICAgICAgICAgICBib2FyZFdpZHRoOiB0aGlzLmJvYXJkV2lkdGgsXHJcbiAgICAgICAgICAgIGxhc3RNb3ZlOiB0aGlzLmxhc3RNb3ZlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RhdGUuamllID0gdGhpcy5qaWU7XHJcblxyXG4gICAgICAgIGxldCBjZWxsTWFwID0ge307XHJcbiAgICAgICAgZm9yKGxldCBpZHggaW4gdGhpcy5jZWxsTWFwKXtcclxuICAgICAgICAgICAgY2VsbE1hcFtpZHhdID0gdGhpcy5jZWxsTWFwW2lkeF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmNlbGxNYXAgPSBjZWxsTWFwO1xyXG5cclxuICAgICAgICBsZXQgYmxvY2tzID0gW107XHJcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8dGhpcy5ibG9ja3MubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBsZXQgaGVhZCA9IHRoaXMuYmxvY2tzW2ldO1xyXG4gICAgICAgICAgICBsZXQgaGVhZDIgPSBuZXcgQ2VsbChoZWFkLngsIGhlYWQueSwgaGVhZC5jb2xvciwgbnVsbCwgbnVsbCwgc3RhdGUsIGhlYWQuaWR4KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBxaSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IobGV0IGlkeFFpIGluIGhlYWQucWkpe1xyXG4gICAgICAgICAgICAgICAgcWlbaWR4UWldID0gaGVhZC5xaVtpZHhRaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGVhZDIucWkgPSBxaTtcclxuXHJcbiAgICAgICAgICAgIGxldCBoZWFkMyA9IGhlYWQyO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUoaGVhZC5uZXh0KXtcclxuICAgICAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQyID0gbmV3IENlbGwoaGVhZC54LCBoZWFkLnksIGhlYWQuY29sb3IsIG51bGwsIG51bGwsIHN0YXRlLCBoZWFkLmlkeCk7XHJcbiAgICAgICAgICAgICAgICBoZWFkMy5uZXh0ID0gY2hpbGQyO1xyXG4gICAgICAgICAgICAgICAgaGVhZDMgPSBjaGlsZDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGhlYWQyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhdGUuYmxvY2tzID0gYmxvY2tzO1xyXG5cclxuICAgICAgICByZXR1cm4gc3RhdGU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrUGllY2UoeCx5LGNvbG9yKXtcclxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXRlLnBsYWNlUGllY2UoeCx5LGNvbG9yKTtcclxuICAgICAgICBpZihyZXN1bHQpe1xyXG4gICAgICAgICAgICBzdGF0ZS5yZXN1bHQgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwbGFjZVBpZWNlKHgseSxjb2xvcil7XHJcblxyXG4gICAgICAgIGxldCBpZHggPSB0aGlzLnh5MmlkeCh4LHkpO1xyXG4gICAgICAgIGxldCBjZWxsID0gbmV3IENlbGwoeCx5LGNvbG9yLG51bGwsbnVsbCx0aGlzLGlkeCk7XHJcblxyXG4gICAgICAgIHRoaXMuY2VsbE1hcFtpZHhdID0gY29sb3I7XHJcblxyXG4gICAgICAgIC8v5ZCI5bm2XHJcbiAgICAgICAgbGV0IGhhc01lcmdlID0gZmFsc2U7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuYmxvY2tzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmJsb2Nrc1tpXS5jb2xvciAhPT0gY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgIGxldCBtZXJnZSA9IGNlbGwubWVyZ2VCbG9jayh0aGlzLmJsb2Nrc1tpXSk7XHJcbiAgICAgICAgICAgaWYobWVyZ2Upe1xyXG4gICAgICAgICAgICAgICAgaGFzTWVyZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja3Muc3BsaWNlKGksMSk7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ibG9ja3MucHVzaChjZWxsKTtcclxuXHJcbiAgICAgICAgbGV0IGppZTtcclxuICAgICAgICAvL+WIpOaWreaPkFxyXG4gICAgICAgIGxldCBoYXNLaWxsID0gZmFsc2U7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuYmxvY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuYmxvY2tzW2ldLmNvbG9yID09PSBjb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBkZWwgPSB0aGlzLmJsb2Nrc1tpXS5kZWxldGVRaShjZWxsKTtcclxuICAgICAgICAgICAgaWYoZGVsKXtcclxuICAgICAgICAgICAgICAgIGxldCBxaUNvdW50ID0gdGhpcy5ibG9ja3NbaV0uZ2V0UWlDb3VudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYocWlDb3VudCA9PT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgemlDb3VudCA9IHRoaXMuYmxvY2tzW2ldLmdldENvdW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vamllXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5qaWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsLmlkeCA9PSB0aGlzLmppZS5pZHgpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih6aUNvdW50PT09MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBoYXNLaWxsID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoemlDb3VudD09PTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqaWUgPSB0aGlzLmJsb2Nrc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8v5Yqg5rCUXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuYmxvY2tzLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmJsb2Nrc1tqXS5jb2xvciAhPT0gY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2Nrc1tqXS5hZGRRaSh0aGlzLmJsb2Nrc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbEtpbGxlZCA9IHRoaXMuYmxvY2tzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGRve1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jZWxsTWFwW2NlbGxLaWxsZWQuaWR4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEtpbGxlZCA9IGNlbGxLaWxsZWQubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9d2hpbGUoY2VsbEtpbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2Nrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNlbGxRaSA9IGNlbGwuZ2V0UWlDb3VudCgpO1xyXG4gICAgICAgIGxldCBoYXNRaSA9IGNlbGxRaT4wO1xyXG5cclxuICAgICAgICBpZighaGFzS2lsbCAmJiAhaGFzUWkpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdE1vdmUgPSBjZWxsO1xyXG4gICAgICAgICAgICB0aGlzLmppZSA9IGppZTtcclxuXHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSAxO1xyXG4gICAgICAgICAgICBpZighaGFzS2lsbCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsbEV5ZSA9IHRoaXMuY2hlY2tFeWUoY2VsbCk7XHJcbiAgICAgICAgICAgICAgICBpZihmaWxsRXllKXtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAyO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFFpID09PSAxKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gMztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tFeWUoY2VsbCl7XHJcbiAgICAgICAgbGV0IHggPSBjZWxsLng7XHJcbiAgICAgICAgbGV0IHkgPSBjZWxsLnk7XHJcbiAgICAgICAgbGV0IGNvbG9yID0gY2VsbC5jb2xvcjtcclxuICAgICAgICBsZXQgaXNFeWUgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZih5LTE+PTApe1xyXG4gICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy54eTJpZHgoeCx5LTEpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmNlbGxNYXBbaWR4XSE9Y29sb3Ipe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHkrMTx0aGlzLmJvYXJkV2lkdGgpe1xyXG4gICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy54eTJpZHgoeCx5KzEpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmNlbGxNYXBbaWR4XSE9Y29sb3Ipe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHgtMT49MCl7XHJcbiAgICAgICAgICAgIGxldCBpZHggPSB0aGlzLnh5MmlkeCh4LTEseSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuY2VsbE1hcFtpZHhdIT1jb2xvcil7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoeCsxPHRoaXMuYm9hcmRXaWR0aCl7XHJcbiAgICAgICAgICAgIGxldCBpZHggPSB0aGlzLnh5MmlkeCh4KzEseSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuY2VsbE1hcFtpZHhdIT1jb2xvcil7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjb3JuZXIgPSAwO1xyXG4gICAgICAgIGxldCBlbmVteSA9IDA7XHJcbiAgICAgICAgaWYoeC0xPj0wKXtcclxuICAgICAgICAgICAgaWYoeS0xPj0wKXtcclxuICAgICAgICAgICAgICAgIGNvcm5lcisrO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IHRoaXMueHkyaWR4KHgtMSx5LTEpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jZWxsTWFwW2lkeF09PS1jb2xvcil7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih5KzE8dGhpcy5ib2FyZFdpZHRoKXtcclxuICAgICAgICAgICAgICAgIGNvcm5lcisrO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IHRoaXMueHkyaWR4KHgtMSx5KzEpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jZWxsTWFwW2lkeF09PS1jb2xvcil7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZih4KzE8dGhpcy5ib2FyZFdpZHRoKXtcclxuICAgICAgICAgICAgaWYoeS0xPj0wKXtcclxuICAgICAgICAgICAgICAgIGNvcm5lcisrO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IHRoaXMueHkyaWR4KHgrMSx5LTEpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jZWxsTWFwW2lkeF09PS1jb2xvcil7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih5KzE8dGhpcy5ib2FyZFdpZHRoKXtcclxuICAgICAgICAgICAgICAgIGNvcm5lcisrO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlkeCA9IHRoaXMueHkyaWR4KHgrMSx5KzEpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jZWxsTWFwW2lkeF09PS1jb2xvcil7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5lbXkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoZW5lbXkvY29ybmVyPj0wLjUpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdGF0ZTsiLCJpbXBvcnQgQ2VsbCBmcm9tIFwiLi9DZWxsXCI7XHJcbmltcG9ydCBOb2RlIGZyb20gXCIuL05vZGVcIjtcclxuaW1wb3J0IFN0YXRlIGZyb20gXCIuL1N0YXRlXCI7XHJcblxyXG5jbGFzcyBHYW1le1xyXG4gICAgY29uc3RydWN0b3IoYm9hcmRXaWR0aCkge1xyXG4gICAgICAgIHRoaXMuY3VyQ29sb3IgPSAxO1xyXG4gICAgICAgIHRoaXMuYm9hcmRXaWR0aCA9IGJvYXJkV2lkdGggfHwgNTtcclxuICAgICAgICB0aGlzLmN1clN0YXRlID0gbmV3IFN0YXRlKHtcclxuICAgICAgICAgICAgYm9hcmRXaWR0aDogdGhpcy5ib2FyZFdpZHRoLFxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmN1clN0YXRlLmxhc3RNb3ZlID0gbmV3IENlbGwoLTEsLTEsLTEsbnVsbCxudWxsLHRoaXMuY3VyU3RhdGUsdGhpcy5jdXJTdGF0ZS54eTJpZHgoLTEsLTEpKTtcclxuICAgICAgICB0aGlzLm5vZGUgPSBuZXcgTm9kZSh7XHJcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmN1clN0YXRlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgLy/kurrmnLrlr7nlvIhcclxuICAgIHBsYWNlUGllY2UoeCx5LGNvbG9yKXtcclxuXHJcbiAgICAgICAgaWYoY29sb3I9PT0xKXtcclxuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5jaGVja1BpZWNlKHgseSxjb2xvcik7XHJcbiAgICAgICAgICAgIGlmKHN0YXRlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VyU3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VyQ29sb3IgPSAtdGhpcy5jdXJDb2xvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2FpXHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMubm9kZS5nZXRDaGlsZCh4LHkpO1xyXG4gICAgICAgICAgICAgICAgaWYoIW5vZGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgTm9kZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLmN1clN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDsgaTwxMDAwOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucnVuT25jZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGJlc3RDaGlsZCA9IG5vZGUuZ2V0TWF4TkNoaWxkKCk7XHJcbiAgICAgICAgICAgICAgICBpZihiZXN0Q2hpbGQpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCBjZWxsID0gYmVzdENoaWxkLnN0YXRlLmxhc3RNb3ZlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VyU3RhdGUgPSBiZXN0Q2hpbGQuc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJDb2xvciA9IC10aGlzLmN1ckNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZSA9IGJlc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8v5Lq65Lq65a+55byIXHJcbiAgICBwbGFjZVBpZWNlUFZQKHgseSxjb2xvcil7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5jaGVja1BpZWNlKHgseSxjb2xvcik7XHJcbiAgICAgICAgaWYoc3RhdGUpe1xyXG4gICAgICAgICAgICB0aGlzLmN1clN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgICAgIHRoaXMuY3VyQ29sb3IgPSAtdGhpcy5jdXJDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tQaWVjZSh4LHksY29sb3Ipe1xyXG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuY3VyU3RhdGUuY2xvbmUoKTtcclxuICAgICAgICBsZXQgdmFsaWQgPSBzdGF0ZS5wbGFjZVBpZWNlKHgseSxjb2xvcik7XHJcbiAgICAgICAgaWYodmFsaWQpe1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHYW1lOyIsImltcG9ydCBHYW1lIGZyb20gXCIuL0dhbWVcIjtcclxuXHJcbmxldCBNeUdvID0ge307XHJcbk15R28uR2FtZSA9IEdhbWU7XHJcblxyXG53aW5kb3cuTXlHbyA9IE15R287Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);